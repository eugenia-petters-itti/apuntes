# Configuración PostgreSQL con problemas de VACUUM
# Archivo: config/postgresql-vacuum-problem.conf

# === CONFIGURACIÓN BÁSICA ===
listen_addresses = '*'
port = 5432
max_connections = 100
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB

# === CONFIGURACIÓN PROBLEMÁTICA DE AUTOVACUUM ===
# PROBLEMA: Autovacuum muy conservador y lento
autovacuum = on
autovacuum_max_workers = 1                    # MUY BAJO - debería ser 3-4
autovacuum_naptime = 60s                      # MUY ALTO - debería ser 15-30s
autovacuum_vacuum_threshold = 500             # MUY ALTO para tablas grandes
autovacuum_vacuum_scale_factor = 0.4          # MUY ALTO - debería ser 0.1-0.2
autovacuum_analyze_threshold = 250            # OK
autovacuum_analyze_scale_factor = 0.2         # OK

# PROBLEMA: Vacuum cost muy restrictivo (hace VACUUM muy lento)
autovacuum_vacuum_cost_delay = 20ms           # MUY ALTO - debería ser 2-10ms
autovacuum_vacuum_cost_limit = 100            # MUY BAJO - debería ser 2000-4000

# === CONFIGURACIÓN DE LOGGING ===
log_destination = 'stderr,csvlog'
logging_collector = on
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d.log'
log_rotation_age = 1d
log_rotation_size = 100MB

# Logging detallado para diagnóstico
log_statement = 'all'
log_min_duration_statement = 1000
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on

# VACUUM logging
log_autovacuum_min_duration = 0               # Log todos los autovacuums

# === CONFIGURACIÓN DE PERFORMANCE ===
# Configuración que empeora el problema
checkpoint_segments = 16                      # Muy bajo para carga alta
checkpoint_completion_target = 0.5            # Podría ser más alto
wal_buffers = 16MB
random_page_cost = 4.0                        # Alto para SSD
effective_io_concurrency = 1                  # Muy bajo para SSD

# === CONFIGURACIÓN DE ESTADÍSTICAS ===
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all
stats_temp_directory = '/var/run/postgresql'

# === EXTENSIONES PARA DIAGNÓSTICO ===
shared_preload_libraries = 'pg_stat_statements'

# Configuración de pg_stat_statements
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# === CONFIGURACIÓN DE MEMORIA ===
# Configuración subóptima que contribuye al problema
shared_buffers = 256MB                        # Podría ser más alto
temp_buffers = 8MB
max_prepared_transactions = 0
work_mem = 4MB                                # Bajo para consultas complejas
maintenance_work_mem = 64MB                   # Bajo para VACUUM de tablas grandes
max_stack_depth = 2MB

# === CONFIGURACIÓN DE CONEXIONES ===
max_connections = 100
superuser_reserved_connections = 3

# === CONFIGURACIÓN DE WAL ===
wal_level = replica
wal_sync_method = fsync
full_page_writes = on
wal_compression = off
wal_log_hints = off
archive_mode = off

# === CONFIGURACIÓN DE REPLICACIÓN ===
max_wal_senders = 10
wal_keep_segments = 32
hot_standby = on
max_standby_archive_delay = 30s
max_standby_streaming_delay = 30s

# === CONFIGURACIÓN DE PLANNER ===
enable_bitmapscan = on
enable_hashagg = on
enable_hashjoin = on
enable_indexscan = on
enable_indexonlyscan = on
enable_material = on
enable_mergejoin = on
enable_nestloop = on
enable_seqscan = on
enable_sort = on
enable_tidscan = on

# === CONFIGURACIÓN DE RECURSOS ===
max_worker_processes = 8
max_parallel_workers_per_gather = 2
max_parallel_workers = 8
max_parallel_maintenance_workers = 2

# === CONFIGURACIÓN DE TIMEOUTS ===
deadlock_timeout = 1s
statement_timeout = 0
lock_timeout = 0
idle_in_transaction_session_timeout = 0

# === CONFIGURACIÓN DE LOCALE ===
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'
default_text_search_config = 'pg_catalog.english'

# === CONFIGURACIÓN DE TIMEZONE ===
timezone = 'UTC'
log_timezone = 'UTC'
